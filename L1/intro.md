# Введение

## Что такое функциональное программирование?
> Это парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних. Функциональное программирование предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций, и не предполагает явного хранения состояния программы. Соответственно, не предполагает оно и изменяемости этого состояния

### Чистые функции

Чистые функции — это первая фундаментальная концепция, которую нужно изучить для того, чтобы понять сущность функционального программирования.

Что такое «чистая функция»? Что делает функцию «чистой»? Чистая функция должна отвечать следующим требованиям:

* Она всегда возвращает, при передаче ей одних и тех же аргументов, один и тот же результат (такие функции также называют детерминированными)
* Такая функция не обладает побочными эффектами

```c
const float PI = 3.14;

float calculateArea(float radius)
{
    return radius * radius * PI;
}

calculateArea(10);
// возвращает 314
```

Эта функция не является чистой: она использует глобальную константу, не переданную в качестве аргумента

Чистый вариант:
```c
const float PI = 3.14;

float calculateArea(float radius, float pi)
{
    return radius * radius * pi;
}

calculateArea(10, PI);
```

Грязная функция с побочным эффектом - чтением файлов
```javascript
function charactersCounter(text) {
  return `Character count: ${text.length}`;
}

function analyzeFile(filename) {
  let fileContent = open(filename);
  return charactersCounter(fileContent);
}
```

Чистые функции также определяют через то их свойство, что вызов можно заменить на результат этого вызова:

<table>
<tr>
<td>

```c
int strlen(const char * s)
{
    int len = 0;
    for (; s && s[len]; len++);
    return len;
}

strlen("Hello"); // => 5
strlen(""); // => 0
```
</td>
<td>

```javascript
function arrlen(string) {
    console.log("Calculating array length...")
    return array.reduce((x, y) => x + 1, 0)
}

arrlen([1, 2, 3, 4]) // => "Calculating array length...", 4
arrlen([1, 1000, 0, 9999, -1, 'kek']) // => "Calculating array length...", 6

```
</td>
</tr>
</table>


## Лямбда-исчисление
### Синтаксис

Всё основывается на λ-термах:

* Переменные x , y , z ... являются термами
* Если M и N – термы, то (M N ) – терм
* Если x – переменная, а M – терм, то (λx. M ) – терм

Соглашения о приоритете операций и скобках:

|| Пишем | Подразумеваем |
|--------|-------|-------------|
| Опустим внешние скобки: | λx. x | (λx. x) |
| В применении группируем скобки влево: | f ghx | ((f g)h)x |
| В функциях группируем скобки вправо: | λx. λy. x | (λx. (λy. x)) |
| Пишем функции нескольких аргументов с одной лямбдой: | λxy. x | (λx. (λy. x)) |

Может показаться, будто нам нужны какие-то специальные механизмы для функций с несколькими аргументами, но на самом деле это не так. Действительно, в мире чистого лямбда-исчисления возвращаемое функцией значение тоже может быть функцией. Следовательно, мы можем применить первоначальную функцию только к одному её аргументу, «заморозив» прочие. В результате получим новую функцию от «хвоста» аргументов, к которой применим предыдущее рассуждение. Такая операция называется каррированием. Выглядеть это будет примерно так:

| Обозначение | Пояснение |
|-----------|----------|
| f = λx.λy.t | Функция с двумя аргументами x и y и телом t |
| f v w | Подставляем в f значения v и w |
| (f v) w | Эта запись аналогична предыдущей, но скобки явно указывают на последовательность подстановки |
| ((λy.[x → v]t) w) | Подставили v вместо x. [x → v]t означает «тело t, в котором все вхождения x заменены на v» |
| [y → w][x → v]t | Подставили w вместо y, преобразование закончено |

**Процесс вычисления**

Рассмотрим следующий терм-применение: $$(λx.t) y$$

Его левая часть — (λx.t) — это функция с одним аргументом x и телом t. Каждый шаг вычисления будет заключаться в замене всех вхождений переменной x внутри t на y. Терм-применение такого вида носит имя редекса (от reducible expression, redex — «сокращаемое выражение»), а операция переписывания редекса в соответствии с указанным правилом называется *β-редукцией*. Если в терме не осталось редексов, то это означает, что он вычислен, или находится в нормальной форме. Есть термы, которые нормальной формы не имеют: $$(λx.xx) (λx.xx)$$
На каждом шаге редукции мы будем вновь и вновь возвращаться к исходному терму


Кроме β-редукции есть ещё *α-преобразование*. Рассмотрим терм $$(λxy. x) y$$ После подстановки за счёт совпадения имён переменных мы получим тождественную функцию $$λy.y$$
Переменная y была свободной, но после подстановки стала связанной. Необходимо исключить такие
случаи. Поскольку с ними получается, что имена связанных переменных в определении функции влияют на её смысл. Таким образом, смысл выражения $(λxz. x) y$ полностью поменяется (упражнение: вычислить терм)

**Стратегии редукции**

Если нам нужно избавиться от всех редексов в выражении, то с какого редекса лучше начать? В вычислении по значению (аппликативная стратегия) мы начинаем с самого левого редекса, который не содержит других редексов, то есть с самого маленького подвыражения. А в вычислении по имени (нормальная стратегия) мы начинаем с самого левого внешнего редекса. Левый редекс означает, что в записи выражения он находится ближе всех к началу выражения. Для дальнейших вычислений поможет

**Теорема (Карри)** Если у терма есть нормальная форма, то последовательное сокращение самого левого внешнего редекса приводит к ней

Эта теорема говорит о том, что стратегия вычисления по имени может вычислить все термы, которые
имеют нормальную форму. В том, что вычисление по значению может не справиться с некоторыми такими
термами, можно убедиться на следующем примере:
$$ (λxy. x) z ((λx. xx)(λx. xx)) $$

Также есть

**Теорема (Чёрча-Россера)** Если терм $X$ редуцируется к термам $Y_1$ и $Y_2$ , то существует терм $L$, к которому редуцируются оба терма $Y_1$ и $Y_2$

Эта теорема говорит о том, что у терма может быть только одна нормальная форма. Поскольку если бы
их было две, то существовал третий терм, к которому можно было бы редуцировать эти нормальные формы. Но по определению нормальной формы, мы не можем её редуцировать. Из этого следует, что нормальные формы должны совпадать.
Теорема Чёрча-Россера указывает на способ сравнения термов. Для того чтобы понять, равны термы или нет, необходимо привести их к нормальной форме и сравнить. Если термы совпадают в нормальной форме, то они равны.



<!-- **Абстракция**

Функции в лямбда-исчислении называют абстракциями. Мы берём терм M и параметризуем его по переменной x в выражении λx.M . При этом если в терме M встречается переменная x, то она становится связанной. Например в терме λx.λy.x Переменная x является связанной, но в терме λy.x , она уже не связана. Такие переменные называют свободными. Множество связанных переменных терма M мы будем обозначать BV(M) (англ. bound variables), а множество свободных переменных мы будем обозначать FV(M) (Free variables). На интуитивном уровне процесс абстракции заключается в том, что мы смотрим на несколько частных случаев и видим в них что-то общее. Это общее мы выделяем в функцию, которая параметризована частностями. Например, мы видим выражения $λx. + xx$ и $λx. ∗ xx$. 

И в том, и в другом у нас есть функция двух аргументов + или *, и мы делаем из неё функцию одного
аргумента. Мы можем абстрагировать (параметризовать) это поведение в такую функцию:
$$λb. λx. bxx$$
-->

**Примеры λ-выражений**

Композиция: $ λfgx. f(gx) $

Арифметические операции: $λxy. + xy$ и $λxy. * xy$

Их обобщение: $λbxy. b xy$, где вместо b может стоять вообще любая бинарная операция

Логические значения

Их суть раскрывается в операторе *If*, с помощью которого мы можем организовывать ветвление. Есть два терма *True* и *False*, которые для любых термов a и b обладают свойствами:
$$If \; True \; a \; b = a$$
$$If \; False \; a \; b = b$$

Термы *True*, *False* и *If*, которые удовлятворяют таким условиям, выглядят вот так (упражнение: проверить терм *if*):
$$True = \lambda t f.\; t$$
$$False = \lambda t f.\; f$$
$$If = \lambda b \; x \; y.\; bxy$$

Логические константы *True* и *False* кодируются константными функциями двух аргументов. В такой интерпретации отрицание можно закодировать функцией *flip*, а операции типа *Or* и *And* выразить через *if*. Например, $Or \; a\; b = \lambda a\; b.\; if\; a\; True\; b$

Так можно реализовать и натуральные числа с арифметическими операциями. Будем кодировать числа Пеано. Для этого нам понадобится нулевой элемент и функция определения следующего элемента. Их можно закодировать так:
$$Zero = \lambda sz.\;z$$
$$Succ = \lambda nsz.\;s(nsz)$$
Как и в случае логических значений, числа кодируются функциями двух аргументов. Число определяется
по терму, подсчётом цепочки первых аргументов s. Вот так выглядит число два (упражнение: раскрыть вывод):
$$2 = Succ\;(Succ\;Zero) = λsz.\;s(sz)$$

### Зачем это всё нужно?

В начале XX в. стоял вопрос о вычислимости функций, и математики подошли к нему с разных сторон. Алан Тьюринг — через абстрактную машину с бесконечной лентой, состояниями и переходами, Алонсо Чёрч — через λ-исчисление. Оказалось, что оба формальных аппарата описывают один и тот же класс функций. Эквивалетность аппаратов можно показать, смоделировав работу одного через другой.




