module Lib
    ( someFunc
    ) where

-- это комментарий

{-
это тоже комментарий, только многострочный
-}

-- вот так мы определяем новые типы данных:
data Nat' = Zero | Succ Nat' deriving (Eq)
-- тип Nat' будет представлять собой натуральные числа
-- читать эту штуку выше можно так:
-- "Тип Nat' представляет собой зиро (ноль) или сакссессор Nat' "
-- вертикальная палка обозначает тип-сумму, и её иногда можно читать как "или"

-- В стандартной библиотеке определён data Maybe a = Nothing | Just a
-- т.е. "ничего" или "какое-то значение типа a"


-- вот так можно реализовать функцию сложения для только что созданных натуральных чисел
add :: Nat' -> Nat' -> Nat'
add Zero y = y
add x Zero = x
add (Succ x) (Succ y) = Succ $ Succ $ add x y

someFunc :: IO ()
someFunc = putStrLn "Hello world!"




p = 7

-- если хотим проигнорировать какие-нибудь аргументы функции, но хотим указать их наличие, то ставим _
add2 :: Int -> Int -> Int -> Int
add2 x _ _ = x + 2



sum :: [Int] -> Int
sum = foldr (+) 0
-- предполагается, что здесь на самом деле sum xs = foldr (+) 0 xs,
-- но польская нотация, отсутствие скобок и механизм частичного применения
-- позволяют опустить имя аргумента
-- Также пример демонстрирует, 
-- что любой инфиксный оператор можно сделать функцией, обернув его в круглые скобки
-- * оператором считается набор "не буквенных" символов. Т.е. создать оператор kek не получится

-- а любую функцию двух аргументов можно сделать инфиксной, если завернуть в косые кавычки
xor :: Bool -> Bool -> Bool
xor x     False = x
xor False y     = y
xor _     _     = False
-- здесь имеет место сопоставление с образцом:
-- если какое-то выражение имеет форму N, то делаем так-то
-- т.е. если второй аргумент имеет форму False, то выдаём первый аргумент (первая строка)
-- если первый аргумент имеет форму False, то даём второй
-- во всех остальных случаях (которые представляют собой только True True) даём False

alwaysFalse = False `xor` False
-- VSCode подсказывает, что alwaysFalse :: Bool, т.е. система вывода типов вполне себе работает
-- это также можно проверить в интерпретаторе, набрав :t alwaysFalse

-- можем определить xor через if:
xor' x y = if x == y then False else True
-- а линтер предлагает вообще заменить это на xor' x y = x /= y
-- т.е. оператор != из других языков в Haskell выглядит как /=,
-- ибо на клавиатуре нет символа неравенства

fact :: Integer -> Integer
fact 0 = 1
fact n = fact' n 1
    where
        fact' 1 acc = acc
        fact' n acc = fact' (n - 1) $! acc * n

    
-- несколько лямбд
someLambdaId = \x -> x
fst' = \(a, _) -> a
snd' = \(_, b) -> b

true' = \t f -> t


quickSort :: Ord a => [a] -> [a]
quickSort [] = []
quickSort (x:xs) = quickSort left ++ [x] ++ quickSort right
    where
        left = [y | y <- xs, y < x]
        right = filter (>= x) xs
        -- или filter (\t -> t >= x) ...

