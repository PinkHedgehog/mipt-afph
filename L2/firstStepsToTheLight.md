# Первые шаги с Haskell

## Stack и сборка проектов

Создание проекта
```bash
$ stack new <project-name> [template]
```
Название шаблона можно не указывать, будет выбран шаблон по умолчанию

Сборка
```bash
$ stack build
```
При первой сборке стэк может подгрузить в изолированное окружение компилятор ghc, чтобы использовать его в личных целях в рамках данного проекта, и чтобы версия установленного в системе компилятора не конфликтовала с зависимостями проекта

Запуск
```bash
$ stack exec -- project-name-exe
```
По умолчанию исполняемый файл называется как проект с припиской -exe в конце

Установка
```bash
$ stack install
```

Интерактивная сессия в контексте проекта
```bash
$ stack ghci
```

Про структуру проекта, модули и организацию файлов с кодом можно подробнее посмотреть в книге Д. Шевченко "О Haskell по-человечески", гл. 4 "Приготовимся" и гл. 16 "Hackage и библиотеки"

# Когда проектов нет

Сборка
```bash
$ ghc filename.hs
```
Появятся три файла: filename.hs, filename.o и filename (filename.exe на Windows)

Запуск
```bash
$ ./filename
```

Интерактивный режим
```bash
$ ghci
```
В интерактивном режиме (aka интерпретатор) можно выполнять код построчно. Кроме того, он предоставляет средства отладки. На данный момент могут пригодиться следующие команды интерпретатора:

* :h или :help - справка по всем командам
* :q или :quit - выход
* :t expr или :type expr - тип expr. expr может быть выражением, функцией, константой
* :i name или :info name - показать всю информацию о name. name может быть функцией, тайпклассом или "чем-то с именем"
* :r или :reload - перезапустить текущий набор модулей
* :l[oad] filename.hs - подгрузить содержимое filename.hs
* :browse Module - вывести все имена и их типы, которые экспортирует Module

Импортировать модули можно через ключевое слово языка import

# Haskell

Примеры определения функций и типов данных можно посмотреть в файле L2/hello/src/Lib.hs.

Из коробки доступен некоторый набор функций и типов данных. Есть типы, называемые примитивными:
* Int - целые знаковые числа, четырёх- или восьмибайтные, зависит от архитектуры машины
* Integer - целые знаковые числа для длинной арифметики, ограничены оперативной памятью машины
* Bool - логические значения - True или False. Если набрать в интерпретаторе :i Bool, то там будет
```haskell
data Bool = True | False
-- Это означает, что значения типа Bool могут быть True или False
```

* () - () - тип Unit, обозначаемый круглыми скобками, имеет в себе единственное значение - круглые скобки
* Char - символы, они записываются в одинарных кавычках
* Float и Double - вещественные числа с плавающей запятой одинарной или двойной точности

Все типы начинаются с большой буквы. Если где-то в определении функции или другого типа встретите что-то с маленькой, то это переменная типа. Т.е. вместо этого типа может быть подставлен какой-нибудь другой.
Например, у нас есть функция
```haskell
id :: a -> a
id x = x
```
В принципе, вместо **a** могло бы стоять что угодно, начинающееся с маленькой буквы. Главное, что одинаковые последовательности обозначают одинаковые типы
```haskell
const :: a1 -> a2 -> a1
const x y = x
```
функция **const** берёт два аргумента любого типа и возвращает свой первый. Очевидно, возвращаемое значение будет типа первого аргумента - **a1**

Любые типы можно группировать в кортежи и списки. Кортежи могут держать в себе значения любых типов, указанных при объявлении кортежа, но не могут изменять длину
```haskell
tuple1 :: (a, b)
tuple1 = (1, 'a')
-- т.е. tuple1 теперь всегда имеет тип (Int, Char)
-- кортежи из двух элементов по-русски обычно называют парой
```
и не могут изменять порядок типов (и элементов) внутри себя
```haskell
(1, 'b') /= ('b', 1)
-- если какая-то функция захочет аргумент типа (Int, Char), то попытка дать ей
-- (Char, Int) не пройдёт тайп-чекер
```

Для пар определены очевидные функции **fst** и **snd**:
```haskell
fst :: (a, b) -> a
snd :: (a, b) -> b
-- представляют собой сокращения от first и second
```

Списки, в отличие от кортежей, могут быть совершенно любой длины (от 0 до бесконечности), но содержат в себе элементы только одного типа, указанного при объявлении.
С ними уже много всякого интересного можно делать:
```haskell
-- можем создать пустой список:
emptyList = []
-- тип указывать не будем, т.к. может быть любым и вообще не важен сейчас

-- можем из одного элемента:
x1 = ['a']
-- компилятор выведет, что x1 :: [Char]
-- а можем из двух:
x2 :: [Double]
x2 = [3.1415926535897932384, 0]

-- можем через оператор втыкания :
x1' = 'a' : []
-- :t (:)
-- (:) :: a -> [a] -> [a]
-- оператор берёт элемент, берёт список элементов того же типа и возвращает новый список,
-- в котором этот элемент становится головой
-- кроме того, по этому оператору можно делать распаковку списка 
-- при сопоставлении с образцом

-- да здравствуют генераторы и list comrehension!
naturalNumbers = [1..] --  натуральные числа от 1 до бск., т.е. 1, 2, 3 и т.д.
bounded3 = [0, 3..10] -- [0, 3, 6, 9] - задаём начальное значение, шаг и верхнюю границу
-- выше этой границы список генерироваться не будет

squares = [x * x | x <- [1..5]]
-- квадраты чисел от 1 до 5
-- значка принадлежности на клавиатуре нет, но есть <-
-- (как если бы спрямить  края и выдавить из него чёрточку)

cartesian = [(x, y) | x <- [1..3], y <- [1..4]]
-- декартово произведение {1, ..., 5} x {1, ..., 5}

primes = filterPrime [2..]
    where
        filterPrime (p:xs) = 
            p : filterPrime [x | x <- xs, x `mod` p /= 0]
-- решето Эратосфена

-- поскольку список генерируется бесконечный, дёрнуть можем его конечную часть
-- например, вот так:
primes !! 10 -- индексация с нуля, будет 31
take 10 primes -- [2,3,5,7,11,13,17,19,23,29]
drop 5 (take 10 primes) -- [13,17,19,23,29]

-- На списках вообще есть много функций, они живут в модуле Data.List
-- наиболее интересные для нас

length :: [a] -> Int -- очевидно
null :: [a] -> Bool -- чекает на пустоту, True для случая [], чекает лениво
-- т.е. если натравливаем null на генератор, и генератор что-то вернёт,
-- null выдаст False и выключит генератор

--право- и левоассоциативные свёртки
-- сворачивают списки типа a с аккумулятором (и начальным значением) типа b,
-- возвращают накопленное значение
-- используются чаще всего для агрегирования какой-нибудь функции по коллекции,
-- не только по списку. Например, суммирование или произведение.
-- Значение аккумулятора, вообще говоря, не обязано быть "простым"
-- это может быть кортеж или другой список
-- левая свёртка слишком ленивая, вместо неё лучше брать foldl' - энергичный вариант

-- реализация:
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f z []     = z
foldr f z (x:xs) = f x (foldr f z xs)

foldl :: (b -> a -> b) -> b -> [a] -> b
foldl f z []     = z
foldl f z (x:xs) = foldl f (f z x) xs

filter :: (a -> Bool) -> [a] -> [a]
-- фильтрует список по предикату

map :: (a -> b) -> [a] -> [b]
-- отображает список типа a в список типа b, применяя к каждому элементу функцию f

-- голова и хвост списка. Падают на пустых списках
head :: [a] -> a
tail :: [a] -> [a]
-- если h - голова некоторого списка, а t - его хвост,
-- то h : t - весь этот список (вспоминаем оператор втыкания)

-- кроме оператора втыкания есть ещё оператор конкатенации
(++) :: [a] -> [a] -> [a]
-- склеивает списки
-- из [1, 32, 3] ++ [5, 6, 7] делает [1, 32, 3, 5, 6, 7]

type String = [Char]
-- из коробки определён тип String - синоним для типа [Char]
-- значения этого типа можно задать не только квадратными скобками
-- или перечислением элементов, но и строковым литералом
-- т.е. набором символов в двойных кавычках ""
-- так, "Hello, world!" :: String

-- значения типа String берут функции вывода на экран
putStr, putStrLn :: String -> IO ()

-- некоторые типы данных могут быть переведены в строковое представление
show :: Show a => a -> String
-- и обратно
read :: Read a => String -> a

-- иногда надо явно давать машине понять, какой тип хотим получить:
read "5" :: Int
-- и
read "5" :: Double
-- выдадут два похожих значения совершенно разных типов  - 5 и 5.0
-- в языках со слабой типизацией одно перекастуется в другое, но не здесь
-- в Haskell типизация сильная статическая

-- для типов, которые можно перевести в строку, есть функция print:
print :: Show a => a -> IO ()
print x = putStrLn . show $ x
-- переводит аргумент в строку и печатает её на экран с переносом строки
```

# Материалы

* L2/hello/src/Lib.hs
* Д. Шевченко, О Haskell по-человечески (ohaskell.pdf или ohaskell-mobile.pdf на Google-диске), главы 4-7
* А. Холомьёв, Учебник по Haskell (ru-haskell-book.pdf на Google-диске), главы 1-5




