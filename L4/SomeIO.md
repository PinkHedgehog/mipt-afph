# Введение в ввод-вывод

## Обработка строк

Основные функции модуля [Data.List](https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-List.html):
```haskell
words   :: String -> [String]
lines   :: String -> [String]
unwords :: [String] -> String
```
Также пригодятся тайпклассы **Show** и **Read**:

```haskell
class Show a where:
    show :: a -> String
    -- тип считается экземпляром тайпкласса Show,
    -- если у любого его значения есть строковое представление
    -- Определён для всех примитивных типов: Int, Double, Bool, Char

class Read a where:
    read :: String -> a
    -- тип считается экземпляром тайпкласса Read,
    -- если его значение можно разобрать из строки
```

Вспомним функцию `map :: (a -> b) -> [a] -> [b]`

С её помощью можем разобрать поток чего-то однотипного, вводимого через пробел:

```haskell
parseLine :: Read a => String -> [a]
parseLine = map read . words
-- Если из контекста компилятор не сможет вывести тип a, то придётся указать его вручную.
-- Например, parseLine "1 2 3" без контекста сломается, выдаст *** Exception: Prelude.read: no parse
-- А если набрать parseLine "1 2 3" :: [Int],
-- то разберётся [1, 2, 3]
-- В случае parseLine "1 2 3" :: [Double] разберётся [1.0, 2.0, 3.0]
```

## Ввод-вывод

В стандартной библиотеке для ввода с консоли определены функции:
```haskell
getChar :: IO Char -- считывает один символ с консоли
getLine :: IO String -- считывает строку до символа переноса или конца ввода
getContents :: IO String -- считывает ленивым образом ВСЁ до конца ввода
```

Поскольку в них фигурирует **IO**, дёргать мы их можем только внутри других функций, содержащих **IO** в типе возврата. К таким функциям относится **main**

Элементарный пример ввода-вывода:
```haskell
main :: IO ()
main = do
    t <- getLine -- синтаксический сахар, который позволит использовать
                 -- значение t :: String, введённое с клавиатуры
                 -- т.е. "распаковать" IO String в String
    putStrLn $ "length of string \"" ++ t ++ "\" is " ++ show (length t)
```

Кроме того, внутри do-блока функции **main** можно делать let-выражения, которые позволят определить именованное значение какой-нибудь сложной конструкции (потенциально бесконечной). Единственное ограничение - let-выражения должны содержать только "простые" функции, без какого-либо IO

```haskell
main :: IO ()
main = do
    n <- read <$> getLine 
    -- можно было сделать n <- getLine
    -- и потом написать take (read n) triangles,
    -- а можно дёрнуть оператор <$>
    -- тип которого (<$>) :: (a -> b) -> f a -> f b,
    -- в данном контексте - (<$>) :: (String -> Int) -> IO String -> IO Int
    -- т.е здесь мы левой стрелкой распаковываем IO Int в Int, а не IO String в String,
    -- как это было в прошлом примере

    let triangles = [ (x, y, z) 
                    | x <- [1..]
                    , y <- [1..x]
                    , z <- [x..(x^2 + y^2)]
                    , z^2 == x^2 + y^2 
                    ]
        -- в этом месте можно определить что-нибудь ещё
        -- главное - соблюдать отступ, чтобы выражения стояли одно под другим
    print $ take n triangles
```

Внутри **main** можно дёргать **getЧто-то** не один раз. Можем, например, дёрнуть **getChar**, а потом за ним дёрнуть **getLine**. Эти действия выполнятся последовательно. Когда-нибудь потом мы узнаем, что do-блок для того и служит, чтобы явно видеть последовательность действий (*привет, императивщина*). Можем даже определить собственные функции ввода на их основе, но пока что надо это делать ооочень аккуратно. Проще считать всё через **getContents** в некую константу, потом её резать по пробелам или переносам строки. Но пример самодельной функции приведём:

```haskell
getDoubles :: IO [Double]
getDoubles = map read . lines <$> getContents
-- потом где-нибудь внутри main можем вызвать функцию getDoubles,
-- которая считает введённые через строку вещественные числа
-- и вернёт их как список значений типа Double
```

Кроме оператора **(<$>)** (который на самом деле лишь элиас для функции **fmap**) есть ещё интересный оператор "фтопку" - **(>>=)**, который можно найти на иконке самого хаскеля, да и вообще везде, где упоминается этот великий ЯП. Его тип такой:
```haskell
(>>=) :: Monad m => m a -> (a -> m b) -> m b
-- где вместо m мы с чистой совестью можем подставить IO

-- В природе есть также его левая версия:
(=<<) :: (a -> IO b) -> IO a -> IO b -- мы пока не знаем других Monad m, кроме IO
```

Левая версия позволит более кратко записать "грязные" операции ввода-вывода, если у нас уже есть чистые функции, решающие задачу:

``` haskell
-- пишем чистые функции:
triangles = [ (x, y, z) 
            | x <- [1..]
            , y <- [1..x]
            , z <- [x..(x^2 + y^2)]
            , z^2 == x^2 + y^2 
            ] -- генератор каких-то троек


-- flip :: (a -> b -> c) -> b -> a -> c
-- flip f x y = f y x
-- flip позволяет скормить функции аргументы в обратном порядке

getTriangles = flip take triangles -- экстрактор скольких-то троек
-- единственный арумент опущен благодаря flip,
-- иначе было бы getTriangles n = take n triangles


main :: IO ()
main = print . getTriangles . read =<< getLine

    -- print :: [(Int, Int, Int)] -> IO ()
    -- getTriangles :: Int -> [(Int, Int, Int)]
    -- print . getTrinagles :: Int -> [(Int, Int, Int)]
    -- read :: String -> Int (в данном контексте)
    -- print . getTriangles . read :: String -> IO ()

```

Т.е. в эту длинную композицию мы можем аки в топку засунуть **IO String**, который есть результат вычисления **getLine**. В итоге решение задачи "в одну строчку". А если ещё зачеркнуть аннотацию типа **main** и комментарии, то получим вот такое:
```haskell
triangles = [ (x, y, z) 
            | x <- [1..]
            , y <- [1..x]
            , z <- [x..(x^2 + y^2)]
            , z^2 == x^2 + y^2 
            ]

getTriangles = flip take triangles

main = print . getTriangles . read =<< getLine
```

Ни одного указания типа, компилятор до всего сам догадается!

